package example

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"cloud.google.com/go/deploy/apiv1/deploypb"
	"cloud.google.com/go/pubsub"
	"github.com/GoogleCloudPlatform/functions-framework-go/functions"
	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/codingconcepts/env"
)

type config struct {
	// Truthfully project ID and location might be able to be gathered by the function instead of env
	ProjectId   string `env:"PROJECTID" required:"true"`
	Location    string `env:"LOCATION" required:"true"`
	SendTopicID string `env:"SENDTOPICID" required:"true"`
}

type PubsubMessage struct {
	// Data is the payload of the message.
	Data []byte `json:"data"`

	// Attributes are optional attributes that can be used to. For example,
	// to. For example, to provide metadata, or to. For example, to filter messages.
	Attributes ApprovalsData `json:"attributes"`

	// MessageId is the ID of the message generated by the server.
	MessageID string `json:"messageId"`

	// PublishTime is the time at which the message was published.
	PublishTime time.Time `json:"publishTime"`

	// OrderingKey is the ordering key of the message.
	OrderingKey string `json:"orderingKey"`
}

type Message struct {
	Message PubsubMessage `json:"message"`
}
type ApprovalsData struct {
	Action         string `json:"Action"`
	Rollout        string `json:"Rollout"`
	ReleaseId      string `json:"ReleaseId"`
	RolloutId      string `json:"RolloutId"`
	TargetId       string `json:"TargetId"`
	Location       string `json:"Location"`
	ProjectNumber  string `json:"ProjectNumber"`
	ManualApproval bool   `json:"manualApproval"`
}

type CommandMessage struct {
	Commmand       string                         `json:"command"`
	ApproveRollout deploypb.ApproveRolloutRequest `json:"approveRolloutRequest"`
}

var c config

func init() {
	functions.CloudEvent("cloudDeployApprovals", cloudDeployApprovals)
	//Load env variables using "github.com/codingconcepts/env"
	if err := env.Set(&c); err != nil {
		_ = fmt.Errorf("error getting env: %s", err)
	}
}

func cloudDeployApprovals(ctx context.Context, e event.Event) error {
	log.Printf("Deploy Approvals function invoked")
	var msg Message
	err := json.Unmarshal(e.Data(), &msg)
	if err != nil {
		// Don't return because it's probably a bad message and we need to ack
		_ = fmt.Errorf("errored unmarshalling data: %v", err)
		return nil
	}
	log.Printf("Waiting 30 seconds to approve for demo")
	time.Sleep(30 * time.Second)
	var a = msg.Message.Attributes
	log.Printf("A is: %v", a)
	if a.Action == "Required" && a.Rollout != "" && a.ManualApproval {
		// Create the rollout
		log.Printf("Creating Rollout and sending to pubsub")
		var command = CommandMessage{
			Commmand: "ApproveRollout",
			ApproveRollout: deploypb.ApproveRolloutRequest{
				Name:     a.Rollout,
				Approved: true,
			},
		}
		err = sendCommandPubSub(ctx, &command)
		if err != nil {
			_ = fmt.Errorf("failed to send pubsub command: %v", err)
			// Let's return nil to ack the bad message. Otherwise the function will rerun and fail.
			return nil
		}
		log.Printf("Deployment triggered successfully")
	}
	// Return nil to ack pubsub message
	return nil
}

// This should be in a shared code folder
func sendCommandPubSub(ctx context.Context, m *CommandMessage) error {
	client, err := pubsub.NewClient(ctx, c.ProjectId)
	if err != nil {
		return fmt.Errorf("pubsub.NewClient: %v", err)
	}
	defer client.Close()
	t := client.Topic(c.SendTopicID)
	// Marshal the CommandMessage into a JSON byte slice
	jsonData, err := json.Marshal(m)
	if err != nil {
		return fmt.Errorf("json.Marshal: %v", err)
	}
	log.Printf("Sending message to PubSub")
	result := t.Publish(ctx, &pubsub.Message{
		Data: jsonData, // Use the JSON byte slice here
	})
	// Block until the result is returned and a server-generated
	// ID is returned for the published message.
	id, err := result.Get(ctx)
	log.Printf("ID: %s, err: %v", id, err)
	if err != nil {
		fmt.Printf("Get: %v", err)
		return nil

	}
	log.Printf("Published a message; msg ID: %v\n", id)
	return nil
}
